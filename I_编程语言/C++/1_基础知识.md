

1. static \ const
   1. static
      1. static成员变量
            ```c++
            class Student{
            public:
            Student(char *name, int age, float score);
            public:
            static int m_total;  //静态成员变量
            };
            // 1. 初始化方式: 类外初始化
            // 2. static成员变量在类外初始化时，才分配内存
            // 3. static成员变量的内存，处在内存分区中的“全局数据区”，既不属于类，也不属于对象
            int Student::m_total = 0;
            ```
      2. static成员函数只能访问static成员变量
    1. const 
       1. const类对象: const T t;
          - 只能访问const成员变量
       2. const成员函数: func run() const
          - 只能访问const成员变量 
2. 虚函数表属于 类？ 对象？
   - 虚函数表属于**类**，不是属于某个对象
   - 每个类对象有一个虚函数指针，指向这个类的公共的虚函数表
3. C++中哪些函数不能声明为virtual
   - 首先要明确，virtual是用于支持类多态的关键字，所以出现在类声明之外的地方都是错误的。
   1. 普通函数（即非类成员函数）不能是virtual的，否则不能通过编译，virtual只能出现在类声明中。
   2. 静态成员函数不能是virtual的
      - 对于static成员函数，没有this指针，不属于对象，属于整个类。==> static成员函数属于类而非单个具体对象，所有的对象共享一份代码，没有实现多态的必要。
   3. inline成员函数可以声明为virtual，但是在编译时不会实际将代码直接在调用处展开。
   4. 友元函数也不能声明为virtual
      - 因为友元关系是不能被继承的，编译会出错
   5. 构造函数（拷贝构造函数/赋值构造函数）不能是virtual的
      - 编译器会为每一个含有virtual函数的类生成一个虚函数表，每个类对象的最前端会包含一个指向该表的指针。
      - 如果构造函数也可以virtual，那么类对象需要有一个虚函数指针指向该虚函数表。但此时类对象并未构造，虚函数指针是不存在的。==> 这就出现了矛盾。
4. virtual与(构造函数/析构函数)
   1. 构造函数不能用virtual修饰（在上文已经解释了）
   2. 析构函数一定要用virtual修饰，防止内存泄露
   3. 绝不在析构和构造函数中调用virtual函数
      - 建议参考[Effective C++ 条款9](http://www.cnblogs.com/lidan/archive/2012/01/13/2321726.html)
5. 构造函数\析构函数能否抛出异常？
   1. 析构函数: 不要在析构函数中抛出异常！
      1. 不要在析构函数中抛出异常！虽然C++并不禁止析构函数抛出异常，但这样会导致程序过早结束或出现不明确的行为。
      2. 如果某个操作可能会抛出异常，class应提供一个普通函数（而非析构函数），来执行该操作。目的是给客户一个处理错误的机会。
      3. 如果析构函数中异常非抛不可，那就用try catch来将异常“吞下”，但这样方法并不好，我们提倡有错早些报出来。
   2. 构造函数: 构造函数中尽量不要抛出异常，能避免的就避免，如果必须，要考虑不要内存泄露！
      1. 构造函数中抛出异常，会导致析构函数不能被调用，但对象本身已申请到的内存资源会被系统释放（已申请到资源的内部成员变量会被系统依次逆序调用其析构函数）。
      2. 因为析构函数不能被调用，所以可能会造成内存泄露或系统资源未被释放。
      3. 构造函数中可以抛出异常，但必须保证在构造函数抛出异常之前，把系统资源释放掉，防止内存泄露。（如何保证？？？使用auto_ptr？？？）
6. i++为什么线程不安全
    - i++本质上分为3个步骤，这3步不是一个原子操作
      > ① 从内存中读取i的值，保存到寄存器: eax = 内存i的值
      >
      > ② 寄存器的值++: eax++
      >
      > ③ 将寄存器的值，写回到内存中的i: 内存i的值 = eax
7. 函数重载/函数隐藏/函数覆盖
   1. 函数重载（静态绑定）
      1. 作用域相同
      2. 函数名相同、形参列表（个数/类型/顺序）不同
      3. 注意: 函数重载不考虑返回值的不同
   2. 函数隐藏
      1. 作用域不同（如，派生类的函数隐藏）
      2. 函数名相同
      3. 形参和返回值不考虑
   3. 函数覆盖(函数重写)
      1. virtual函数
      2. 作用域不同（必须在继承关系下的基类/子类）
      3. 形参列表（个数/类型/顺序）必须相同（子类可以不写virtual关键字）
8. explicit关键字
   1. 修饰类的构造函数
   2. 防止类构造函数的隐式自动转换
9. 常量const
10. vector的clear()函数
    1. 调用clear之后, vector的尺寸(size)将变成0，但它的容量(capacity)却并不发生变化, vector本身并不释放任何内存
    2. vector的内存释放: swap
11. [C++ static_cast、dynamic_cast、const_cast和reinterpret_cast](http://c.biancheng.net/view/2343.html)
12. RTTI: Run-Time Type Identification 运行时类型识别
    1. 运行时类型识别，在C++层面主要体现在**dynamic_cast**和**typeid**
    2. 具体实现原理: VS中虚函数表的-1位置存放了指向type_info的指针，对于存在虚函数的类型，dynamic_cast和typeid都会去查type_info
13. RAII 资源获取即初始化
    1.  RAII，也称为“资源获取就是初始化”，是c++等编程语言常用的管理资源、避免内存泄露的方法。它保证在任何情况下，使用对象时先构造对象，最后析构对象
    2.  应用
      1. shard_ptr
      2. lock_guard: 它是一个互斥量包装程序，它提供了一种方便的RAII（Resource acquisition is initialization ）风格的机制来在作用域块的持续时间内拥有一个互斥量。
14. C++函数栈的最大值: 默认是1M，不过可以调整


---


http://c.biancheng.net/cplus/c2cpp/
