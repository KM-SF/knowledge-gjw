

支付宝转账1万到余额宝(支付宝扣除1万，余额宝累加1万): 支付宝扣款 + 余额宝加钱

## 1. [简单版本](https://www.cnblogs.com/huangying2124/p/11702761.html)：基于RocketMq，不保证回滚

事先说明，该方案有个缺陷，不支持事务的回滚

- 支付宝扣款成功了，消息也发了，但是下游消费出现问题，导致余额宝加钱失败了。这种异常场景将由MQ消费者的失败重试机制来保证，暂时不考虑该场景 ==> 即: 不支持事务1的回滚操作，认为一旦生产者成功，消费者也一定成功

### 1.1. 生产者: 支付宝扣款 + 确认发送MQ消息

1. 发送Half消息
2. 执行本地事务: 以下2个操作封装成一个transaction
   1. 支付宝扣款(此时，事务已经提交到DB)
   2. 记录本地事务的执行状态status
      1. 支付宝事务提交状态
      2. 已发送确认MQ消息(最大努力通知，保证发送确认MQ消息能成功)
      3. 已经回滚(幂等，保证不会多次回滚)
      4. 已经Finish
3. 根据本地事务的执行结果，执行以下两个操作
   1. 成功: 确认MQ的Half消息的状态为“已经提交”，此时，消息能被消费
   2. 失败: 取消MQ的Half消息，消息将被丢弃
4. [异常场景考虑] 支付宝扣款业务方，需要要提供事务执行状态的回查接口
   1. 场景: 当执行步骤3发送MQ消息失败时(即没有提交给MQ时)，
   2. 解决方案: MQ的broker会启动定时器，回查事务执行的状态
      1. 查询到事务执行成功，则确认Half消息
      2. 查询到事务执行失败 or 未查询到(则重试15次) ==> 则丢弃Half消息

### 1.2. 消费者: 消费MQ消息 + 余额宝加钱

1. 消费MQ消息
   - 先写入本地消息表，本地消息表的最大努力通知机制，保证2件事
      1. 余额宝加钱一定能成功
      2. 扭转本地事务1的状态


----------------------------------------------------------------

## 2. 复杂版本: 基于Rocket，增加策略，保证回滚

如何设计一种支持回滚本地事务1的一种方案呢？

异常场景: 回滚事务1
1. 事务1执行成功，消息已经发送到MQ，但是MQ崩了，导致消费者接收不到消息
   - 事务1，提供定时器机制，扫描[`已经发送确认消息状态 && 事务2未提交 && 超时时间大于阈值`]的记录，执行回滚操作
2. 事务2执行失败(分2类case): 失败，就一直重试，直到成功。但是重试次数大于阈值，执行回退策略
   1. 超时失败: 超时失败，可能已经执行成功
      - 消费者定时器，查询本地消息表[`未完成的任务 && 事务1已经提交 && 超时时间大于阈值`]的任务，执行回滚操作
   2. 非超时失败(错误失败)
      - 错误次数超过阈值，直接回滚事务1
