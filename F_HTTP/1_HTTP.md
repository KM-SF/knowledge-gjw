### HTTP

超文本传输协议，用于在web浏览器传输文本

- 为什么HTTP使用TCP不使用UDP？
  - HTTP要求很高，不能随便出错，使用TCP能保证可靠传输，与此同时TCP能提供流量/拥塞控制

- Chrome浏览器，采用多线程/多进程？
  - 多进程。因为如果采用多线程，一个浏览器页面挂掉，所有的页面都有挂掉的风险，采用多线程，不能保证不出意外

#### HTTP请求报文

- 请求方法 请求URL HTTP协议以及版本号，如：POST /chapter17/user.html HTTP/1.1

- 报文头

- 报文体

#### HTTP响应报文

- HTTP协议以及版本号 状态码 状态码描述，如：HTTP/1.1 200 OK
- 响应头
- 响应体

##### 请求方法

GET：获取URI资源（返回所有信息，包括报文首部、报文体）

HEAD：只获取报文首部，不获取报文体（用于确认URI的有效性、资源更新的日期）

POST：传输报文主体，一般用于更新

PUT：传输文件，保存到URI指定的位置

DELETE：删除文件，与PUT方法相反

TRACE：追踪路径，查询发送出去的请求的中转路径

CONNECT：要求与代理服务器通信时，建立隧道，实现用隧道协议进行TCP通信（主要使用SSL/TLS）

OPTIONS：查看该URI支持哪些请求方法



### GET/POST

> 1. GET产生一个TCP数据包；POST产生两个TCP数据包
>
>    - 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）
>
>    - 对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。
>
> 2. 请求参数是否会完整保留在浏览器的历史记录
>
>    GET √  POST X
>
> 3. URL长度限制
>
>    GET 有限制  POST 无限制
>
> 4. 对参数的数据类型 / 编码方式
>
>    GET只接受ASCII字符   POST没有限制
>
>    GET只能进行url编码   POST支持多种编码方式
>
> 5. 安全性(URL参数暴露)
>
>    GET比POST更不安全，因为参数直接暴露在URL上，POST放在Request body中
>
> 6. 缓存
>
>    GET请求会被浏览器主动cache   POST不会，除非手动设置
>
> 7. 回退
>
>    GET在浏览器回退时是无害      POST会再次提交请求

----



#### HTTP特点

- 无连接：一请求，一连接。即：每次请求都会建立连接，请求完成后，就断开连接
- 无状态：不保存上次请求的状态信息

HTTP上面的2个特点，会带来缺点，即：每次请求不会保持上一次的状态，比如，在购物网站中，如果用户登录了信息，在点击下一个网页后，连接将会断开，需要重新再次输入账号/密码登录，这样十分麻烦。因此引入了HTTP-keepalive保持连接，Cookie、Session保存状态

- keepalive
  - 持久连接（长连接）：减少连接/断开的次数，降低消耗
  - 只要某一端没有明确提出断开连接，就会保持TCP连接状态

- Cookie
  - 保存在客户端
  - 客户端向服务端发起请求后，服务端会生成Cookie返回给客户端；客户端之后将会保存Cookie；当再次访问时，将会把Cookie放在报文头中传给服务端；服务端收到Cookie后，解析Cookie，发现这个请求是客户端A发来的，就直接可以向客户端A回复响应
- Session
  - 会话，保存在服务端
  - 比如：XShell，在第一次登录时，会生成Session，保存起来，它是保存在服务端的内存中

---



#### 状态码

- 1XX 信息状态码，接收的请求正在被处理中
- 2XX 成功状态码，请求处理成功
  - 200 处理成功
  - 204 处理成功，返回内容不包含主体，No content
  - 206 处理成功，返回部分主体，partial content
- 3XX 重定向状态码
  - 301 永久重定向，旧的URL地址资源被永久移除了，转移到新的URL地址
  - 302 临时重定向，旧的URL地址仍然存在，该重定向临时跳转到新的URL地址
  - 307 临时重定向（暂时性转移），如果请求不是GET/HEAD，浏览器禁止自动重定向
  - 304 Not Modify（缓存），客户端连续多次请求相同的URL资源，后请求的将会直接从缓存中获取
- 4XX 客户端发来错误的请求
  - 400 请求保存存在语法问题
  - 401 发送的请求需要HTTP认证
  - 403 没有权限，拒绝访问
  - 404 没有资源
- 5XX 服务端出问题，不能处理请求
  - 500 Internal Server Error，服务器处理请求时，发生错误
  - 503 Service Unavailable，服务不可达，可能是因为服务器负载过高or正在停机维护

---

## Cookie / Session

​        由于HTTP是无状态的，服务端单从网络连接上无法知道客户端身份，Cookie/Session引入解决了该问题。

#### Cookie

Cookie存储在`客户端浏览器`中。

案例: 当在浏览器上登录邮箱的账号密码时，浏览器会提示你“记住密码”？。这就是Cookie机制

下次登录邮箱时，直接登录就可以，无需再次输入密码

1. 客户端请求连接服务器，服务器会给客户端颁发一个通行证。(set-cookie)
2. 客户端浏览器会把Cookie保存起来，这样，客户端下次连接时，携带该通行证
3. 浏览器检查该Cookie，以此来辨认客户端的身份

​        很多网站都有Cookie，Cookie不能跨域名，即：根据Cookie规范，浏览器访问Google只会携带Google的Cookie，而不会携带Baidu的Cookie。Google也只能操作Google的Cookie，而不能操作Baidu的Cookie。

#### Session 会话

Session存储在`服务器`中（服务端维护了一张客户端明细表来确认客户端身份），因此，增加了服务器的存储压力。为了获得更高的存取速度，服务器一般把Session放在内存里。

客户端浏览器访问服务器的时候，服务器把客户端的信息以某种形式记录在服务器中，这就是Session。

1. 每个客户端的Session对象创建时期：客户端在第一次请求并连接服务器时
2. 客户端登录浏览器的时候，只需要查询服务器上保存的“客户端明细表”

Cookie/Session区别

1. 保存位置：cookie数据存放在客户的浏览器上，session数据放在服务器上
2. 安全性：cookie不是很安全，别人可以分析存放在本地的cookie，并进行cookie欺骗
3. 失效时间：session很容易失效，用户体验很差
4. 生命周期：Session是IE启动到IE关闭，(浏览器页面一关，session就消失了)。Cookie是预先设置的生存周期，或永久的保存于本地的文件



---

### HTTPS

HTTPS = HTTP + 加密 + 认证 + 完整性校验，HTTPS是身披SSL外壳的HTTP。采用SSL后，HTTP就拥有了加密、证书、完整性校验的特性

#### HTTP、HTTPS的区别

- 是否明文传输：SSL/TLS建立安全通信线路
- 是否验证对方身份：SSL证书
- 是否验证报文完整性：MD5/RSA/数字签名

关于加密的应用场景举例：一般在下载软件的时候，经常会提供一个MD5检验值。当下载完软件后，可以计算该软件包MD5值，判断是否相等来判断该软件包是否正确。

#### 公钥加密/私钥加密

- 共享公钥加密（对称加密）
  - 双方采用相同的密钥对数据加密
  - 缺点：公钥要在网络中传播，存在被盗的危险
- 公开密钥加密（非对称加密）
  - 公钥是公开的，所有人都可以拿到公钥。
  - 私钥只有主人持有
  - 其他人将数据采用公钥进行加密，发送给持有私钥的主人，主人通过私钥解密

非对称加密也是有一个小的风险，就是：公钥是否是正确的，是否是货真价实的？如果公钥是假的，那么，用假公钥加密后的数据将会泄漏。因此，引出了“CA数字证书认证机构”，它会颁发证书，证明公钥的权威性。



问题：既然HTTPS那么安全可靠，为什么所有的Web网站不都使用HTTPS？

- HTTPS加密通信会消耗更多的CPU和内存资源，导致处理请求数量降低。网络负载可能会慢2~100倍。

#### HTTPS安全通信机制

![](https://github.com/gEricy/knownledge/blob/master/HTTP/HTTPS%E5%AE%89%E5%85%A8%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6.png)

---

### HTTP/2.0

与HTTP/1.x相比，HTTP/2.0做了哪些改进呢？

- 多路复用：允许在同一个时刻，对同一URL发起多次请求，同时对多次请求予以相应

  - HTTP/1.x，浏览器在同一个时间，请求同一URL具有一定数量的限制，超过该数量上限的请求都会被阻塞。
  - HTTP/2.0虽然只有一条TCP连接，但是在裸机上分成了很多stream

- 二进制分帧

  - 在不改动HTTP/1.x的语义/方法/状态码/URI等的情况下，HTTP/2.0是如何做到（突破HTTP/1.x的性能限制，改善传输性能，实现低延迟和高吞吐量）的呢？

  - 答：在应用层、传输层之间增加一个二进制分帧层！

    在二进制分帧层中，HTTP/2.0会将所有传输的信息分割成更小的消息和帧，并对它们采用二进制格式的编码

- 请求优先级

- 流量控制

  - 类似于TCP滑动窗口来控制流量，数据接收方通过告诉发送方它能接收的窗口大小

- 服务器推送

  - 客户端请求资源X，而服务器知道它很可能也需要资源Z的情况下，服务器会将资源Z一起推送给客户端

- 首部压缩

- TLS：更安全的SSL



---

### Web攻击技术

- XSS跨站脚本攻击
- SQL注入攻击
- OS命令注入攻击
- 目录穿越攻击
- 会话劫持
- 密码破解
- DDOS攻击





---

### 其他问题

1. 怎么验证证书的有效性
2. Https加密过程
3. HTTP1.0 1.1 2.0 区别

---

### 访问网页全过程
1.DNS解析(53)：域名-->IP地址(DNS缓存、hosts文件)

2.HTTP(80)：生成HTTP请求报文

3.TCP：3次握手建立连接

4.IP：路由，查询目标地址

5.ARP：IP地址-->MAC地址(ARP缓存)，因为数据要在数据链路层传输，要转换为MAC地址

6.服务器回应HTTP请求，执行相反操作(RARP-->IP路由-->TCP传输-->HTTP解析数据包)

7.渲染页面