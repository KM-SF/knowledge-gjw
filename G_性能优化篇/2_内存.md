# 1.内存
1. 虚拟内存
   1. 并不是所有的虚拟内存都分配物理内存，只有首次使用时，才分配物理内存，分配完物理内存后，通过内存映射来管理
   2. 页表：虚拟内存地址与物理内存地址的映射关系
   3. 页表存储在内存管理单元MMU中，这样，处理器就直接通过硬件，找出访问的内存
   4. TLB是MMU中页表的高速缓存
2. 内存分配与回收 
   1. mallc是C标准库中提供的内存分配函数，对应到系统调用上，即brk()、mmap()
      1. <128K：采用brk()
         1. 通过移动堆顶的位置来分配内存
         2. 这些内存释放后并不会立即归还系统，而是被缓存起来，这样可以重复利用
      2. \>128K：直接使用内存映射mmap()来分配
         1. 也就是在文件映射段找一块空闲内存分配出去
         2. 释放时，会直接归还给系统，所以每次mmap都会发生缺页异常
   2. 伙伴系统
   3. slab机制
   4. 内存回收策略
      1. LRU
      2. 回收不常访问的内存，把“不常用”的内存通过swap分区直接写到磁盘上
         1. 在内存不足时，swap分区才发生交换
         2. 由于磁盘读写的速度<<内存，swap会导致严重的内存性能问题
      3. 杀死进程，内存紧张时系统通过OOM，直接杀死占用大量内存的进程
3. 查看进程使用情况：
   1. free
        ```shell
        $ free
                    total         used        free       shared  buff/cache   available
        Mem:        8169348      263524     6875352         668     1030472     7611064
        Swap:             0           0           0
        ```
        - total：总内存大小
        - used：已经使用内存的大小，包含共享内存
        - free：未使用内存的大小
        - shard：共享内存的大小
        - buff：对裸磁盘(块设备)的缓存，如，/dev/sda
        - cache：对文件系统的缓存，如，/tmp/file
        - availbale：新进程可用内存的大小
    2. top(按M)
        ```shell
        $ top
                    total         used        free       shared  buff/cache   available
        Mem:        8169348      263524     6875352         668     1030472     7611064
        Swap:             0           0           0
        ```
        - VIRT 是进程虚拟内存的大小，只要是进程申请过的内存，即便还没有真正分配物理内存，也会计算在内。（虚拟内存通常并不会全部分配物理内存。从上面的输出，你可以发现每个进程的虚拟内存都比常驻内存大得多）
        - RES 是常驻内存的大小，也就是进程实际使用的物理内存大小，但不包括 Swap 和共享内存。（共享内存 SHR 并不一定是共享的，比方说，程序的代码段、非共享的动态链接库，也都算在 SHR 里）
        - SHR 是共享内存的大小，比如与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等。
        - %MEM 是进程使用物理内存占系统总内存的百分比。
4. 缓存命中率
   1. 工具
      1. cachestat 整个系统的读写命中情况
      2. cachetop  每个进程的缓存命中情况

# 2.内存泄露，如何定位和处理

1. 工具：memleak
   1. 跟踪系统或指定进程的内存分配、释放请求，然后定期输出一个未释放内存和相应调用栈的汇总情况（默认 5 秒）
   2. 执行memleak
        ```shell
        $ /usr/share/bcc/tools/memleak -p $(pidof app) -a
        Attaching to pid 12512, Ctrl+C to quit.
        [03:00:41] Top 10 stacks with outstanding allocations:
            addr = 7f8f70863220 size = 8192
            addr = 7f8f70861210 size = 8192
            addr = 7f8f7085b1e0 size = 8192
            addr = 7f8f7085f200 size = 8192
            addr = 7f8f7085d1f0 size = 8192
            40960 bytes in 5 allocations from stack
                fibonacci+0x1f [app]
                child+0x4f [app]
                start_thread+0xdb [libpthread-2.27.so] 
        ```
        - 可以看到，app中的函数fibonacci，发生了内存泄露
# 3.swap机制

1. 场景
   1. 在内存资源紧张时，Linux 通过直接内存回收和定期扫描的方式，来释放文件页和匿名页，以便把内存分配给更需要的进程使用。
      1. 文件页的回收比较容易理解，直接清空，或者把脏数据写回磁盘后再释放。
      2. 匿名页的回收，需要通过 Swap 换出到磁盘中，下次访问时，再从磁盘换入到内存中。
2. 原理
   1. Swap 说白了就是把一块磁盘空间或者一个本地文件（以下讲解以磁盘为例），当成内存来使用。它包括换出和换入两个过程
      1. 换出，就是把进程暂时不用的内存数据存储到磁盘中，并释放这些数据占用的内存
      2. 换入，则是在进程再次访问这些内存的时候，把它们从磁盘读到内存中来。
   2. 所以你看，Swap 其实是把系统的可用内存变大了。这样，即使服务器的内存不足，也可以运行大内存的应用程序
